/*** Licensed under the KARMA v.1 Law of Sharing. As others have shared freely to you, so shall you share freely back to us.* If you shall try to cheat and find a loophole in this license, then KARMA will exact your share,* and your worldly gain shall come to naught and those who share shall gain eventually above you.* In compliance with previous GPLv2.0 works of Jorg Janke, Low Heng Sin, Carlos Ruiz and contributors.* This Module Creator is an idea put together and coded by Redhuan D. Oon (red1@red1.org)*/package org.my.process;
import org.compiere.process.ProcessInfoParameter;
import java.util.List;
import org.compiere.model.Query;
import org.compiere.util.Env;import org.compiere.util.TimeUtil;import java.sql.SQLException;import java.math.BigDecimal;
import java.sql.PreparedStatement;
import org.compiere.util.DB;
import org.adempiere.exceptions.AdempiereException;import org.compiere.model.MInOut;import org.compiere.model.MOrderLine;import org.compiere.model.MProduct;
import org.compiere.model.MSequence;import org.compiere.model.PO;
import org.my.model.MWM_DeliveryScheduleLine;import org.my.model.MWM_EmptyStorage;import org.my.model.MWM_EmptyStorageLine;import org.my.model.MWM_HandlingUnit;import org.my.model.MWM_HandlingUnitHistory;import org.my.model.MWM_InOut;import org.my.model.MWM_InOutLine;import org.my.model.MWM_PreferredProduct;import org.my.model.MWM_ProductType;import org.my.model.MWM_StorageType;import org.my.model.MWM_WarehousePick;import org.my.model.X_WM_HandlingUnit;
import org.compiere.process.SvrProcess;

	public class CreatePutawayList extends SvrProcess {	private int M_Warehouse_ID = 0; 	private int WM_HandlingUnit_ID = 0; 	private int WM_InOut_ID = 0;	private boolean IsSameDistribution = false;
	private boolean IsSameLine = true;	private String RouteOrder = ""; //normal	private String X = "999"; 	private String Y = "999";	private String Z = "999";	private int putaways;	private int pickings;	private boolean picking;	private int notReceived=0;	private boolean isReceived=false;
	protected void prepare() {
		ProcessInfoParameter[] para = getParameter();
			for (ProcessInfoParameter p:para) {
				String name = p.getParameterName();
				if (p.getParameter() == null)					;
				else if(name.equals("WM_HandlingUnit_ID")){
					WM_HandlingUnit_ID = p.getParameterAsInt();
				}						else if(name.equals("IsSameLine")){					IsSameLine = (Boolean)p.getParameterAsBoolean();				}				else if(name.equals("M_Warehouse_ID")){				M_Warehouse_ID = p.getParameterAsInt();				}
				else if(name.equals("IsSameDistribution")){
					IsSameDistribution = "Y".equals(p.getParameter());
				}
				else if(name.equals("X")){
					X = (String)p.getParameter();
				}
				else if(name.equals("Y")){
					Y = (String)p.getParameter();
				}
				else if(name.equals("Z")){
					Z = (String)p.getParameter();				}						else if(name.equals("RouteOrder")){					RouteOrder = p.getParameterAsString();				}					else if(name.equals("WM_InOut_ID")){					WM_InOut_ID = p.getParameterAsInt();				}	
			}
		}
	protected String doIt() {
		String whereClause = "EXISTS (SELECT T_Selection_ID FROM T_Selection WHERE T_Selection.AD_PInstance_ID=? AND T_Selection.T_Selection_ID=WM_DeliveryScheduleLine.WM_DeliveryScheduleLine_ID)";

		List<MWM_DeliveryScheduleLine> lines = new Query(Env.getCtx(),MWM_DeliveryScheduleLine.Table_Name,whereClause,get_TrxName())
		.setParameters(getAD_PInstance_ID()).list();
				MWM_InOut inout = null;		if (WM_InOut_ID>0) {			inout = new Query(Env.getCtx(), MWM_InOut.Table_Name, MWM_InOut.COLUMNNAME_WM_InOut_ID+"=?", get_TrxName())					.setParameters(WM_InOut_ID)					.first();		} else {			inout = new MWM_InOut(Env.getCtx(),0,get_TrxName());			inout.setC_BPartner_ID(lines.get(0).getWM_DeliverySchedule().getC_BPartner_ID());			inout.setWM_DeliverySchedule_ID(lines.get(0).getWM_DeliverySchedule_ID());			inout.setName(lines.get(0).getWM_DeliverySchedule().getName());			inout.setIsSOTrx(lines.get(0).getWM_DeliverySchedule().isSOTrx());			inout.setWM_Gate_ID(lines.get(0).getWM_DeliverySchedule().getWM_Gate_ID());		}		inout.saveEx(get_TrxName());		putaways = 0;		pickings = 0;
		for (MWM_DeliveryScheduleLine line:lines){						if (line.getWM_InOutLine_ID()>0)				continue;//already done						if (!line.isReceived()){				notReceived++;				isReceived=false;			} else				isReceived=true;						//running balance in use thru-out here			BigDecimal balance =line.getQtyDelivered();										//get Product from InOut Bound line			MProduct product = (MProduct) line.getM_Product();						//If No Handling Unit required at this juncture, then no M_Locator putAway also. Manual way.			if (WM_HandlingUnit_ID<1 && !line.getWM_DeliverySchedule().isSOTrx()) {				newInOutLine(inout,line,balance);				continue;// avoid Locator and EmptyStorage			}			//if Handling Unit is set, then assign while creating WM_InOuts. EmptyLocators also assigned. Can be cleared and reassigned in next Info-Window			//if Picking, then 			if (line.getWM_DeliverySchedule().isSOTrx()){				picking = true;				 if (!doPicking(inout,line))					 log.warning("Check Log for any SEVERE messages. Could not finish picking: "+line.getQtyOrdered()+" "+line.getM_Product().getName());				continue;			}			//check if defined in PreferredProduct...			List<MWM_PreferredProduct> preferreds = new Query(Env.getCtx(),MWM_PreferredProduct.Table_Name,MWM_PreferredProduct.COLUMNNAME_M_Product_ID+"=?" ,get_TrxName())					.setParameters(product.get_ID())					.setOrderBy(MWM_PreferredProduct.COLUMNNAME_M_Locator_ID)					.list();			boolean done=false;			if (preferreds!=null){				for (MWM_PreferredProduct preferred:preferreds){					 					if (M_Warehouse_ID>0){						if (preferred.getM_Locator().getM_Warehouse_ID()!=M_Warehouse_ID)							continue; 					}					if (preferred.getM_Locator().getX().compareTo(X)>=0 || preferred.getM_Locator().getY().compareTo(Y)>=0  || preferred.getM_Locator().getZ().compareTo(Z)>=0 )						continue;					//get next EmptyStorage, if fit, then break, otherwise if balance, then continue					int locator_id = preferred.getM_Locator_ID();					balance = startPutAwayProcess(inout,line,balance,locator_id);					if (balance.compareTo(Env.ZERO)>0)						continue;					else {						done=true;						break;					}				}			} 			if (done)				continue; //done but go to next DeliveryScheduleLine as this is the outermost For Loop.						//get ProductType = StorageType			MWM_ProductType prodtype = new Query(Env.getCtx(),MWM_ProductType.Table_Name,MWM_ProductType.COLUMNNAME_M_Product_ID+"=?",get_TrxName())					.setParameters(product.get_ID())					.first();			 	if (prodtype!=null){			 		String prodtypestring = prodtype.getTypeString();					if (prodtypestring==null || prodtypestring.isEmpty())						throw new AdempiereException("RUN Set Type String for faster processing"); 										List<MWM_StorageType> stortypes= new Query(Env.getCtx(),MWM_StorageType.Table_Name,MWM_StorageType.COLUMNNAME_TypeString+"=?",get_TrxName())							.setParameters(prodtypestring)							.setOrderBy("Created")							.list();									for (MWM_StorageType stortype:stortypes){												if (stortype!=null){							if (stortype.getM_Locator().getX().compareTo(X)>=0 || stortype.getM_Locator().getY().compareTo(Y)>=0  || stortype.getM_Locator().getZ().compareTo(Z)>=0 )								continue;							if (M_Warehouse_ID>0)								if (stortype.getM_Locator().getM_Warehouse_ID()!=M_Warehouse_ID)									continue;														//get next EmptyStorage, if fit, then break, otherwise if balance, then continue							int locator_id = stortype.getM_Locator_ID(); 							balance = startPutAwayProcess(inout,line,balance,locator_id);							if (balance.compareTo(Env.ZERO)>0)								continue;							else {								done=true;								break;							}						}						}			 	}							 if (done)					continue; //enough, i already putaway all.			//get non reserved empty storage			List<MWM_EmptyStorage> empties = new Query(Env.getCtx(),MWM_EmptyStorage.Table_Name,MWM_EmptyStorage.COLUMNNAME_IsFull+"=?",get_TrxName())				.setParameters(false)				.list();							if (empties==null)				throw new AdempiereException("NO MORE EMPTY STORAGE");						for (MWM_EmptyStorage empty:empties){				if (M_Warehouse_ID>0)					if (empty.getM_Locator().getM_Warehouse_ID()!=M_Warehouse_ID)						continue;				if (empty.getM_Locator().getX().compareTo(X)>=0 || empty.getM_Locator().getY().compareTo(Y)>=0  || empty.getM_Locator().getZ().compareTo(Z)>=0 )						continue;			//if has StorType then continue also			MWM_StorageType storagetype = new Query(Env.getCtx(),MWM_StorageType.Table_Name,MWM_StorageType.COLUMNNAME_M_Locator_ID+"=?",get_TrxName())					.setParameters(empty.getM_Locator_ID())					.first();			if (storagetype!=null)				continue;						//if has PreferredProduct then continue also			MWM_PreferredProduct preferred = new Query(Env.getCtx(),MWM_StorageType.Table_Name,MWM_StorageType.COLUMNNAME_M_Locator_ID+"=?",get_TrxName())					.setParameters(empty.getM_Locator_ID())					.first();			if (preferred!=null)				continue;							//get next EmptyStorage, if fit, then break, otherwise if balance, then continue				int locator_id = empty.getM_Locator_ID();				balance = startPutAwayProcess(inout,line,balance,locator_id);				if (balance.compareTo(Env.ZERO)>0)					continue;				else {					break;				}			}		}		sortFinalList(inout);				if (picking)			return "Successful Pickings: "+pickings+" (Future: "+notReceived+")";
	
		return "Successful Putaways: "+putaways+" (Future: "+notReceived+")";	}	private boolean doPicking(MWM_InOut inout,MWM_DeliveryScheduleLine line) {  		MProduct product = (MProduct)line.getM_Product();		if (product==null) {			log.severe("Fatal: Suddenly Delivery Line has no Product!");			return false;		}		//check if there was WM_WarehousePick (for preselected pick during Sales Order)		if (line.getC_OrderLine_ID()>0){line.getM_Product().getName();			if  (orderLineWarehousePick(inout, line))				return true; 		}				//NOrmal (shortest), FIfo, or LIfo based on previous putaway date start order		List<MWM_EmptyStorageLine>elines = null;		if (RouteOrder.equals("NO")) {			elines = new Query(Env.getCtx(),MWM_EmptyStorageLine.Table_Name,MWM_EmptyStorageLine.COLUMNNAME_M_Product_ID+"=? AND "+MWM_EmptyStorageLine.COLUMNNAME_QtyMovement+">?",get_TrxName())					.setParameters(product.get_ID(),0)					.setOrderBy(MWM_EmptyStorageLine.COLUMNNAME_WM_EmptyStorage_ID)					.list();		}else if (RouteOrder.equals("FI")) {			elines = new Query(Env.getCtx(),MWM_EmptyStorageLine.Table_Name,MWM_EmptyStorageLine.COLUMNNAME_M_Product_ID+"=? AND "+MWM_EmptyStorageLine.COLUMNNAME_QtyMovement+">?",get_TrxName())					.setParameters(product.get_ID(),0)					.setOrderBy(MWM_EmptyStorageLine.COLUMNNAME_DateStart)					.list();		}else if (RouteOrder.equals("LI")) {			elines = new Query(Env.getCtx(),MWM_EmptyStorageLine.Table_Name,MWM_EmptyStorageLine.COLUMNNAME_M_Product_ID+"=? AND "+MWM_EmptyStorageLine.COLUMNNAME_QtyMovement+">?",get_TrxName())						.setParameters(product.get_ID(),0)						.setOrderBy(MWM_EmptyStorageLine.COLUMNNAME_DateStart+" DESC")						.list();		}else{			elines = new Query(Env.getCtx(),MWM_EmptyStorageLine.Table_Name,MWM_EmptyStorageLine.COLUMNNAME_M_Product_ID+"=? AND "+MWM_EmptyStorageLine.COLUMNNAME_QtyMovement+">?",get_TrxName())					.setParameters(product.get_ID(),0)					.setOrderBy(product.getGuaranteeDays()>0?MWM_EmptyStorageLine.COLUMNNAME_DateStart:MWM_EmptyStorageLine.COLUMNNAME_DateStart+" DESC")					.list();		}		if (elines==null){			log.severe("Product has no Storage available to pick: "+product.getName());			return false;		}					BigDecimal binPickQty = line.getQtyOrdered();//.multiply(new BigDecimal(product.getUnitsPerPack())); 		for (MWM_EmptyStorageLine eline:elines){			if (eline.getWM_InOutLine().getM_InOutLine_ID()<1 && line.isReceived())				throw new AdempiereException("This Product Has No Shipment/Receipt record. Complete its WM Inout first before picking - "+product.getName()+" -> "+eline.getWM_InOutLine());						//cannot take Blocked			MWM_EmptyStorage storage = new Query(Env.getCtx(),MWM_EmptyStorage.Table_Name,MWM_EmptyStorage.COLUMNNAME_WM_EmptyStorage_ID+"=?",get_TrxName())					.setParameters(eline.getWM_EmptyStorage_ID())					.first();			if (storage.isBlocked())				continue;						//take those that are Complete DocStatus (Putaway) or no HandlingUnit			MWM_HandlingUnit hu = new Query(Env.getCtx(),MWM_HandlingUnit.Table_Name,MWM_HandlingUnit.COLUMNNAME_DocStatus+"=? AND "+MWM_HandlingUnit.COLUMNNAME_WM_HandlingUnit_ID+"=?",get_TrxName())					.setParameters(MWM_HandlingUnit.DOCSTATUS_Completed,eline.getWM_HandlingUnit_ID())					.first();			if (hu==null)				continue; //next EmptyLine until not InProgress						//Locator EmptyLine Quantity has less than what you picking			if (eline.getQtyMovement().compareTo(binPickQty)>=0){ 				binPickQty = startPickingProcess(binPickQty,inout,line, eline);				pickings++;				return true;							//Locator EmptyLine Quantity has more than what you picking				}else if(!IsSameLine) { //if not SameLine  				binPickQty = startPickingProcess(eline.getQtyMovement(),inout,line, eline);				pickings++;				return true;			}  		}		return false;	}	private boolean orderLineWarehousePick(MWM_InOut inout, MWM_DeliveryScheduleLine line) {		MWM_WarehousePick wp = new Query(Env.getCtx(),MWM_WarehousePick.Table_Name,MWM_WarehousePick.COLUMNNAME_C_OrderLine_ID+"=?",get_TrxName())				.setParameters(line.getC_OrderLine_ID())				.first();		if (wp!=null){			MWM_EmptyStorageLine sel = new Query(Env.getCtx(), MWM_EmptyStorageLine.Table_Name,MWM_EmptyStorageLine.COLUMNNAME_WM_EmptyStorageLine_ID+"=? AND "					+MWM_EmptyStorageLine.COLUMNNAME_M_Product_ID+"=?", get_TrxName())					.setParameters(wp.getWM_EmptyStorageLine_ID(),wp.getM_Product_ID())					.first();			if (sel==null){				log.severe("WarehousePick by Sales OrderLine is lost!:"+wp.toString());			}else {				BigDecimal picked = sel.getQtyMovement();				if (picked.compareTo(wp.getQtyOrdered())==0) { 					picked = startPickingProcess(picked,inout, line, sel);				}				if (picked.compareTo(Env.ZERO)==0){					wp.setDescription(wp.getDescription()+" SUCCESS DURING PICKING!"); 					wp.saveEx(get_TrxName());					return true;				}else {					log.severe("Cannot pickingEmptyStorage - "+sel.toString());					return false;			}}}		return false;	}	private BigDecimal startPickingProcess(BigDecimal picked, MWM_InOut inout, MWM_DeliveryScheduleLine line,MWM_EmptyStorageLine eline) {		// TODO Auto-generated method stub		MWM_EmptyStorage empty = (MWM_EmptyStorage) eline.getWM_EmptyStorage();				//Locator EmptyLine Quantity has more than what you picking		if (eline.getQtyMovement().compareTo(picked)>0){			//if got handling unit, then assign the minor picked to new handling unit. Otherwise reject this reset			if (WM_HandlingUnit_ID>0){				MWM_InOutLine inoutline = newInOutLine(inout,line,picked); 				setLocator(inoutline, eline.getWM_EmptyStorage().getM_Locator_ID());				if (isReceived)					inoutline = assignHandlingUnit(inoutline, empty, picked);								newEmptyStorageLine(line, picked, empty, inoutline);								BigDecimal available = picked.multiply(new BigDecimal(eline.getM_Product().getUnitsPerPack()));							available = available.add(empty.getAvailableCapacity());				available = available.add(getFutureStorage(empty, line));								if (isReceived)					empty.setAvailableCapacity(available);				picked = Env.ZERO;//picking finished			}else { 				return picked;//go next EmptyLine until ExactFit			}					//Locator EmptyLine Quantity has exactly same size what you picking			} else {			MWM_InOutLine inoutline = newInOutLine(inout,line,picked); 			setLocator(inoutline, eline.getWM_EmptyStorage().getM_Locator_ID());			if (isReceived)				releaseHandlingUnitHistory(line,inoutline, eline);			eline.setDateEnd(isReceived?line.getWM_DeliverySchedule().getDatePromised():inoutline.getUpdated());			eline.saveEx(get_TrxName());		}		if (isReceived)				calculatePercentageVacant(empty);//empty.saved() there 		return picked;	}	/**	 * TODO Handling Unit will be fully released during CompleteIt() of WM_InOut > M_InOut	 * @param oline	 * @param empty	 */	private void releaseHandlingUnitHistory(MWM_DeliveryScheduleLine dsline,MWM_InOutLine oline, MWM_EmptyStorageLine empty) {		MWM_HandlingUnit hu = (MWM_HandlingUnit) empty.getWM_HandlingUnit();		if (hu==null){			log.severe("HandlingUnit not found for EmptyLine at this Locator - "+empty.getWM_EmptyStorage().getM_Locator().getValue());			return;		} 		MWM_HandlingUnitHistory huh = new Query(Env.getCtx(),MWM_HandlingUnitHistory.Table_Name,MWM_HandlingUnitHistory.COLUMNNAME_WM_HandlingUnit_ID+"=? AND "		+MWM_HandlingUnitHistory.COLUMNNAME_DateEnd+" IS NULL",get_TrxName())				.setParameters(hu.get_ID()).first();		if (huh==null) {			log.severe("No Handling Unit to release (DateEnd IS null)");			return;		}		huh.setDateEnd(isReceived?dsline.getWM_DeliverySchedule().getDatePromised():oline.getUpdated());			huh.saveEx(get_TrxName()); 	}	/**	 * 	 * @param balance	 * @param locator_id	 * @return balance of unallocated qty to empty storage	 */	private BigDecimal startPutAwayProcess(MWM_InOut inout, MWM_DeliveryScheduleLine dsline, BigDecimal balance, int locator_id) {		MWM_EmptyStorage empty = new Query(Env.getCtx(),MWM_EmptyStorage.Table_Name,MWM_EmptyStorage.COLUMNNAME_M_Locator_ID+"=?",get_TrxName())				.setParameters(locator_id)				.first();		if (empty==null)			throw new AdempiereException("No Empty Storage set for locator id: "+locator_id);				//if its full go back and look for next EmptyStorage		if (empty.isFull())			return balance;		//allotted holds for underlying EmtpyStorageLine detail		BigDecimal alloted = balance;		//check if its vacant capacity can handle the balance.		//pack factor is multiplied into VacantCapacity denominator.		MProduct product = (MProduct) dsline.getM_Product();		BigDecimal PackFactor = new BigDecimal(product.getUnitsPerPack());		 		BigDecimal available = empty.getAvailableCapacity().divide(PackFactor);				available=available.add(getFutureStorage(empty, dsline));				if (balance.compareTo(available)>=0 && IsSameLine==false){			if (isReceived)				empty.setAvailableCapacity(Env.ZERO);			balance = balance.subtract(available);				alloted = available;		} else {			available = available.subtract(balance);			if (available.compareTo(Env.ZERO)<0)//available insufficient				return balance;			if (isReceived)				empty.setAvailableCapacity(available.multiply(PackFactor));			alloted = balance;			balance = Env.ZERO;		}  		MWM_InOutLine inoutline = newInOutLine(inout,dsline,alloted); 		setLocator(inoutline,locator_id); 		inoutline = assignHandlingUnit(inoutline,empty,alloted);		newEmptyStorageLine(dsline,alloted,empty,inoutline);		if (isReceived)			calculatePercentageVacant(empty);		 		return balance;	}		private BigDecimal getFutureStorage(MWM_EmptyStorage empty, MWM_DeliveryScheduleLine dline){		BigDecimal forecastStorage =Env.ZERO;		List<MWM_EmptyStorageLine> slines = new Query(Env.getCtx(),MWM_EmptyStorageLine.Table_Name,MWM_EmptyStorageLine.COLUMNNAME_DateStart+"<?",get_TrxName())				.setParameters(dline.getWM_DeliverySchedule().getDatePromised())				.setOnlyActiveRecords(true)				.list();		for (MWM_EmptyStorageLine sline:slines){			if (sline.getDateEnd().before(dline.getWM_DeliverySchedule().getDatePromised()))				continue;			if (sline.isSOTrx())				forecastStorage=forecastStorage.subtract(sline.getQtyMovement());			else 				forecastStorage=forecastStorage.add(sline.getQtyMovement());		}				return forecastStorage;	}	private MWM_InOutLine newInOutLine(MWM_InOut inout, MWM_DeliveryScheduleLine dsline, BigDecimal alloted) {		MWM_InOutLine inoutline = new MWM_InOutLine(Env.getCtx(),0,get_TrxName());		inoutline.setWM_InOut_ID(inout.get_ID());		inoutline.setC_UOM_ID(dsline.getC_UOM_ID());		inoutline.setC_OrderLine_ID(dsline.getC_OrderLine_ID());		inoutline.setM_Product_ID(dsline.getM_Product_ID());		inoutline.setQtyPicked(alloted);		inoutline.setWM_DeliveryScheduleLine_ID(dsline.get_ID());		inoutline.saveEx(get_TrxName());		return inoutline;	}	private void setLocator(MWM_InOutLine line, int put_pick) { 		line.setM_Locator_ID(put_pick);		line.saveEx(get_TrxName());		putaways++;	}	private void newEmptyStorageLine(MWM_DeliveryScheduleLine dsline, BigDecimal alloted, MWM_EmptyStorage empty, MWM_InOutLine inoutline) {		MWM_EmptyStorageLine storline = new MWM_EmptyStorageLine(Env.getCtx(),0,get_TrxName());		storline.setWM_EmptyStorage_ID(empty.get_ID());		storline.setWM_InOutLine_ID(inoutline.getWM_InOutLine_ID());		storline.setQtyMovement(alloted);		storline.setIsSOTrx(inoutline.getWM_InOut().isSOTrx());		if (isReceived)			storline.setDateStart(dsline.getWM_DeliverySchedule().getDateDelivered());		else			storline.setDateStart(dsline.getWM_DeliverySchedule().getDatePromised());				MProduct product = (MProduct)dsline.getM_Product();		if (product.getGuaranteeDays()>0)			storline.setDateEnd(TimeUtil.addDays(storline.getUpdated(), product.getGuaranteeDays()));				storline.setC_UOM_ID(inoutline.getC_UOM_ID());		storline.setM_Product_ID(inoutline.getM_Product_ID());		storline.setWM_HandlingUnit_ID(inoutline.getWM_HandlingUnit_ID());		storline.saveEx(get_TrxName()); 	}	private void calculatePercentageVacant(MWM_EmptyStorage empty) {//divide(b, 2, RoundingMode.HALF_UP)		if (!isReceived)			return;//future, do not want to affect statistics of EmptyStorage		empty.setPercentage((empty.getAvailableCapacity().divide(empty.getVacantCapacity(),2,BigDecimal.ROUND_HALF_UP)).multiply(Env.ONEHUNDRED));		//set is Full if 0% vacant		if (empty.getPercentage().compareTo(Env.ZERO)==0)			empty.setIsFull(true);		else			empty.setIsFull(false);		empty.saveEx(get_TrxName());	}	private MWM_InOutLine assignHandlingUnit(MWM_InOutLine inoutline, MWM_EmptyStorage empty, BigDecimal qty) { 		MWM_HandlingUnit hu = new Query(Env.getCtx(),MWM_HandlingUnit.Table_Name,MWM_HandlingUnit.COLUMNNAME_WM_HandlingUnit_ID+">=? AND "+MWM_HandlingUnit.COLUMNNAME_QtyMovement+"=?",get_TrxName())				.setParameters(WM_HandlingUnit_ID,Env.ZERO)				.setOrderBy(X_WM_HandlingUnit.COLUMNNAME_Name)				.first();		if (hu==null){			log.severe("No Available Handling Unit starting from: "+WM_HandlingUnit_ID);			return null;		}		if (inoutline.getWM_InOut().isSOTrx()) //so no other picking can touch this			hu.setDocStatus(X_WM_HandlingUnit.DOCSTATUS_InProgress);		else 			hu.setDocStatus(X_WM_HandlingUnit.DOCSTATUS_Completed);		hu.setQtyMovement(qty);		hu.setM_Product_ID(inoutline.getM_Product_ID());		WM_HandlingUnit_ID = hu.get_ID();		hu.saveEx(get_TrxName());				//create new history		MWM_HandlingUnitHistory huh = new MWM_HandlingUnitHistory(Env.getCtx(),0,get_TrxName());		huh.setWM_HandlingUnit_ID(WM_HandlingUnit_ID);		huh.setWM_InOutLine_ID(inoutline.get_ID());		huh.setC_Order_ID(inoutline.getC_OrderLine().getC_Order_ID());		huh.setQtyMovement(qty);		huh.setC_UOM_ID(inoutline.getC_UOM_ID());		huh.setM_Product_ID(inoutline.getM_Product_ID());		huh.setDateStart(hu.getUpdated());		huh.saveEx(get_TrxName());				inoutline.setWM_HandlingUnit_ID(WM_HandlingUnit_ID);		inoutline.saveEx(get_TrxName());		return inoutline;	}	private void sortFinalList(MWM_InOut inout) {		//sort inout list according to XYZ		List<MWM_InOutLine>iolines = new Query(Env.getCtx(),MWM_InOutLine.Table_Name,MWM_InOutLine.COLUMNNAME_WM_InOut_ID+"=?",get_TrxName())				.setParameters(inout.get_ID())				.setOrderBy(MWM_InOutLine.COLUMNNAME_M_Locator_ID)				.list();		int seq = 1;		for (MWM_InOutLine line:iolines){				line.setSequence(new BigDecimal(seq));			line.saveEx(get_TrxName());			seq++;					}	}		
}
