/*** Licensed under the KARMA v.1 Law of Sharing. As others have shared freely to you, so shall you share freely back to us.* If you shall try to cheat and find a loophole in this license, then KARMA will exact your share,* and your worldly gain shall come to naught and those who share shall gain eventually above you.* In compliance with previous GPLv2.0 works of Jorg Janke, Low Heng Sin, Carlos Ruiz and contributors.* This Module Creator is an idea put together and coded by Redhuan D. Oon (red1@red1.org)*/package org.wms.process;
import java.math.BigDecimal;import java.sql.Timestamp;import java.util.List;import org.adempiere.exceptions.AdempiereException;import org.compiere.model.MInOut;import org.compiere.model.MMovement;import org.compiere.model.MMovementLine;import org.compiere.model.MProduct;
import org.compiere.model.Query;import org.compiere.process.ProcessInfoParameter;
import org.compiere.process.SvrProcess;
import org.compiere.util.Env;import org.wms.model.MWM_DeliveryScheduleLine;import org.wms.model.MWM_EmptyStorage;import org.wms.model.MWM_EmptyStorageLine;import org.wms.model.MWM_HandlingUnit;import org.wms.model.MWM_HandlingUnitHistory;import org.wms.model.MWM_InOutLine;import org.wms.model.MWM_StorageType;
	/**	 * HandlingUnit extract a Locator's content to another Locator's 	 * Can move SameDistribution (add on to a HandlingUnit)	 * Can move to Type of Locators instead of single.	 * If No HU, then move all. If yes, partially by Qty or Percent to move.	 * 	 * @author red1	 * @version 1.0	 */
	public class StockMovement extends SvrProcess {
	private int WM_HandlingUnit_ID = 0; 	private BigDecimal Percent = Env.ZERO; 	private BigDecimal QtyMovement = Env.ZERO;  	private int M_Locator_ID = 0; 	private int WM_Type_ID = 0;  	private int done=0;	private boolean IsSameDistribution=false;	private boolean IsSameLine=false;	private boolean movement; 	Timestamp now = new Timestamp (System.currentTimeMillis()); 	private String trxName = "";		protected void prepare() {
		ProcessInfoParameter[] para = getParameter();
			for (ProcessInfoParameter p:para) {
				String name = p.getParameterName();
				if (p.getParameter() == null)					;
				else if(name.equals("WM_HandlingUnit_ID")){
					WM_HandlingUnit_ID = p.getParameterAsInt();
			}
				else if(name.equals("Percent")){
					Percent = p.getParameterAsBigDecimal();
			}
				else if(name.equals("QtyMovement")){
					QtyMovement = p.getParameterAsBigDecimal();
			} 
				else if(name.equals("M_Locator_ID")){
					M_Locator_ID = p.getParameterAsInt();
			}					else if(name.equals("WM_Type_ID")){				WM_Type_ID = p.getParameterAsInt();			}					else if(name.equals("IsSameDistribution")){				IsSameDistribution = p.getParameterAsBoolean();			}				else if(name.equals("IsSameLine")){				IsSameLine = p.getParameterAsBoolean();			}
		}
	}
	MWM_HandlingUnit hu = null;	int storTypeCounter = 0;	List<MWM_StorageType> stortypes = null;	MMovement move = null; //init for Material Movement at end 	String whereClause = "";	List<MWM_EmptyStorageLine> selection = null;	MWM_InOutLine ioline = null;	MWM_DeliveryScheduleLine dline = null;	MWM_EmptyStorage source = null;	MProduct product = null;	MWM_EmptyStorage target = null;	BigDecimal balance = Env.ZERO;	Utils util = null;		private void setTrxName() {		trxName = get_TrxName();	}	protected String doIt() {		setTrxName();		util = new Utils(trxName);		util.setHandlingUnit(WM_HandlingUnit_ID);		checkParams();		//HandlingUnit to split the storage contents 
		selection = selectionSQLwhere();  		
		for (MWM_EmptyStorageLine line:selection){			getInOutLine(line);			getDeliveryScheduleLine(line);			//Product			product = (MProduct) line.getM_Product();			//source Storage			source = (MWM_EmptyStorage)line.getWM_EmptyStorage();			getPercentOrQty(line);			//goto target to fit available pack Qty			mainRoutine(line);			done++;
		}
		return "Lines done: "+done;
	}	private void checkParams() {		if (WM_HandlingUnit_ID>0){		} else {			if (selection.size()>1)				throw new AdempiereException("Only one selection allowed if move without handling unit.");		}	}	private List<MWM_EmptyStorageLine> selectionSQLwhere() {		whereClause = "EXISTS (SELECT T_Selection_ID FROM T_Selection WHERE T_Selection.AD_PInstance_ID=? AND T_Selection.T_Selection_ID=WM_EmptyStorageLine.WM_EmptyStorageLine_ID)";		List<MWM_EmptyStorageLine> lines = new Query(Env.getCtx(),MWM_EmptyStorageLine.Table_Name,whereClause,trxName)		.setParameters(getAD_PInstance_ID())		.list();		return lines;	}	private void getInOutLine(MWM_EmptyStorageLine line) {		ioline = new Query(Env.getCtx(),MWM_InOutLine.Table_Name,MWM_InOutLine.COLUMNNAME_WM_InOutLine_ID+"=?",trxName)				.setParameters(line.getWM_InOutLine_ID())				.first();		if (ioline==null)			throw new AdempiereException("StorageLine Movement has no WMS InOut record.");				}	private void getDeliveryScheduleLine(MWM_EmptyStorageLine line) {		dline = new Query(Env.getCtx(),MWM_DeliveryScheduleLine.Table_Name,MWM_DeliveryScheduleLine.COLUMNNAME_WM_DeliveryScheduleLine_ID+"=?",trxName)				.setParameters(ioline.getWM_DeliveryScheduleLine_ID())				.first();		if (dline==null)			throw new AdempiereException("StorageLine Movement does not have associated DeliveryLine");					if (!dline.isReceived()) {			throw new AdempiereException("StorageLine is not Received in its DeliveryScheduleLine. Not done for: "+line);		}	}	private void getPercentOrQty(MWM_EmptyStorageLine line) {		//define buffer as either QtyMovement or Percent value.				if (Percent.add(QtyMovement).compareTo(Env.ZERO)==0)			balance=line.getQtyMovement();		if (Percent.compareTo(Env.ZERO)>0){			balance = line.getQtyMovement().divide(Env.ONEHUNDRED, 2,BigDecimal.ROUND_HALF_UP);			balance = balance.multiply(Percent);		}else			balance=QtyMovement;					if (balance.compareTo(line.getQtyMovement())>0)			balance = line.getQtyMovement();	}	private void mainRoutine(MWM_EmptyStorageLine line) { 		while (balance.compareTo(Env.ZERO)>0){			if (WM_Type_ID>0)				getStorageFromType(); 			setTargetToLocator(); 			BigDecimal alloted = allotQtyMovement(line);			if (alloted.compareTo(balance)==0)				continue;			endSourceLine(line,alloted);			createReceiptShipmentRecord(line,alloted);		}	}	/**	 * Counter incremented after each read	 * @param storTypeCounter	 * @return	 */	private void getStorageFromType() {		if (stortypes==null){			stortypes = new Query(Env.getCtx(),MWM_StorageType.Table_Name,MWM_StorageType.COLUMNNAME_WM_Type_ID+"=?",trxName)					.setParameters(WM_Type_ID).list();			if (stortypes==null)				throw new AdempiereException("WM_Type get StorageType fail");		}		M_Locator_ID = stortypes.get(storTypeCounter).getM_Locator_ID();		 target = new Query(Env.getCtx(),MWM_EmptyStorage.Table_Name,MWM_EmptyStorage.COLUMNNAME_M_Locator_ID+"=?",trxName)		.setParameters(M_Locator_ID)		.first();		storTypeCounter++;	}	private void setTargetToLocator() {		target = new Query(Env.getCtx(),MWM_EmptyStorage.Table_Name,MWM_EmptyStorage.COLUMNNAME_M_Locator_ID+"=?",trxName)				.setParameters(M_Locator_ID).first();		if (target==null)			throw new AdempiereException("No EmptyStorage for Locator:"+M_Locator_ID);	}	/**	 * Allot if available balance space at Target Storage	 * @return	 */	private BigDecimal allotQtyMovement(MWM_EmptyStorageLine line) {  		BigDecimal balanceFactor=balance.multiply(new BigDecimal(product.getUnitsPerPack()));		BigDecimal available = target.getAvailableCapacity(); 		BigDecimal alloted = balance;		if (available.compareTo(balanceFactor)<0)			if (IsSameLine && WM_Type_ID==0 || WM_HandlingUnit_ID==0)				throw new AdempiereException("Insufficient space at Target Storage for: "+balance+" X "+product.getName());			else				alloted=available.divide(new BigDecimal(product.getUnitsPerPack()),2,BigDecimal.ROUND_HALF_UP);		if (IsSameLine && available.compareTo(balanceFactor)<0)			return balance;					target.setAvailableCapacity(available.subtract(alloted));			target.setAvailableCapacity(available.subtract(alloted));			target.saveEx(trxName);				source.setAvailableCapacity(source.getAvailableCapacity().add(alloted));		source.saveEx(trxName);		MWM_EmptyStorageLine eline = util.newEmptyStorageLine(dline, alloted, target, ioline);		balance = balance.subtract(alloted);		util.calculatePercentageVacant(dline, target);		util.calculatePercentageVacant(dline, source);		//update HU History		if (WM_HandlingUnit_ID>0) {			util.assignHandlingUnit(IsSameDistribution, ioline, eline, alloted);			//update old Handling Unit history 			MWM_HandlingUnitHistory ohuh = new Query(Env.getCtx(),MWM_HandlingUnitHistory.Table_Name,MWM_HandlingUnitHistory.COLUMNNAME_WM_HandlingUnit_ID+"=?",trxName)					.setParameters(line.getWM_HandlingUnit_ID())					.first();			ohuh.setQtyMovement(ohuh.getQtyMovement().subtract(alloted));			if (ohuh.getQtyMovement().compareTo(Env.ZERO)==0)				ohuh.setDateEnd(source.getUpdated());			ohuh.saveEx(trxName);		}		else			;//Do Nothing further - change Locator only		return alloted;	}	private void endSourceLine(MWM_EmptyStorageLine line,BigDecimal alloted) {		line.setQtyMovement(line.getQtyMovement().subtract(alloted));		if (line.getQtyMovement().compareTo(Env.ZERO)==0){			line.setDateEnd(source.getUpdated());			util.releaseHandlingUnit(line);			line.setIsActive(false);		}		line.saveEx(trxName);	}	private void createReceiptShipmentRecord(MWM_EmptyStorageLine line,BigDecimal alloted) {		//check if core M_InOut exist, then create a Material Movement record.		if (ioline.getM_InOutLine_ID()>0 && movement==false){			//check Material Receipt has been completed			MInOut inout = (MInOut) ioline.getM_InOutLine().getM_InOut();			if (!inout.getDocStatus().equals(MInOut.DOCSTATUS_Completed))				throw new AdempiereException("Material Receipt Not Completed: "+ioline.getM_Product().getName()+" at Locator: "+ioline.getM_Locator().getValue());			move = new MMovement(Env.getCtx(),0,get_TrxName());			move.setMovementDate(now);			move.saveEx(get_TrxName());			movement=true;		}		if (ioline.getM_InOutLine_ID()>0){			MMovementLine moveline = new MMovementLine(move);			moveline.setM_Locator_ID(ioline.getM_Locator_ID());			moveline.setM_LocatorTo_ID(M_Locator_ID);			moveline.setM_Product_ID(line.getM_Product_ID());			moveline.setMovementQty(alloted);			moveline.saveEx(trxName);			move.saveEx(trxName);		}			}  
}
